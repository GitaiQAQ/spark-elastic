{"name":"Spark-elastic","tagline":"This project combines Apache Spark and Elasticsearch to enable mining & prediction for Elasticsearch.","body":"![Dr.Krusche & Partner PartG](https://raw.github.com/skrusche63/spark-elastic/master/images/dr-kruscheundpartner.png)\r\n\r\n## Integration of Elasticsearch with Spark\r\n\r\nThis project shows how to easily integrate [Apache Spark](http://spark.apache.org), a fast and general purpose engine for \r\nlarge-scale data processing, with [Elasticsearch](http://elasticsearch.org), a real-time distributed search and analytics \r\nengine.\r\n\r\nSpark is an in-memory processing framework and outperforms Hadoop up to a factor of 100. Spark is accompanied by \r\n\r\n* [MLlib](https://spark.apache.org/mllib/), a scalable machine learning library,\r\n* [Spark SQL](https://spark.apache.org/sql/), a unified access platform for structured big data,\r\n* [Spark Streaming](https://spark.apache.org/streaming/), a library to build scalable fault-tolerant streaming applications.\r\n\r\nCombining Apache Spark and Elasticsearch brings the power of machine learning, real-time data sources such as social media and \r\nmore to an Enterprise Search Platform. \r\n\r\n***\r\n\r\n### <a name=\"1\"></a>Read from Elasticsearch using Spark\r\n\r\nBesides linguistic and semantic enrichment, for data in a search index there is an increasing demand to apply knowledge discovery and\r\ndata mining techniques, and even predictive analytics to gain deeper insights into the data and further increase their business value.\r\n\r\nOne of the key prerequisites is to easily connect existing data sources to state-of-the art machine learning and predictive analytics \r\nframeworks.\r\n\r\nIn this project, we give advice how to connect Elasticsearch, a powerful distributed search engine, to Apache Spark and profit from the increasing number of existing machine learning algorithms.\r\n\r\nThe figure shows the integration pattern for Elasticsearch and Spark from an architectural persepctive and also indicates how to proceed with the enriched content (i.e. the way back to the search index).\r\n\r\n![Elasticsearch and Spark](https://raw.githubusercontent.com/skrusche63/spark-elastic/master/images/Elasticsearch%20and%20Spark.png)\r\n\r\nThe source code below describes a few lines of Scala, that are sufficient to read from Elasticsearch and provide data for further mining \r\nand prediction tasks:\r\n\r\n```\r\n\r\n/**\r\n * Read from ES using inputformat from org.elasticsearch.hadoop;\r\n * note, that key [Text] specifies the document id (_id) and\r\n * value [MapWritable] the document as a field -> value map\r\n */\r\nval source = sc.newAPIHadoopRDD(conf, classOf[EsInputFormat[Text, MapWritable]], classOf[Text], classOf[MapWritable])\r\nval docs = source.map(hit => {\r\n\r\n  val id = hit._1.toString()\r\n  val dc = toMap(hit._2)\r\n      \r\n  (id,dc)\r\n      \r\n}).collect\r\n\r\n```\r\n\r\n#### <a name=\"1.1\"></a> K-Means Segmentation by Geo Location\r\n\r\nFrom the data format extracted from Elasticsearch `RDD[(String,Map[String,String]` it is just a few lines of Scala to segment these documents with respect to their geo location (latitude,longitude). \r\n\r\nTo this end, the [K-Means clustering](http://http://en.wikipedia.org/wiki/K-means_clustering) implementation \r\nof [MLlib](https://spark.apache.org/mllib/) is used:\r\n\r\n```\r\n\r\nobject EsKMeans {\r\n\r\n  /**\r\n   * This method segments an RDD of documents clustering the assigned (lat,lon) geo coordinates.\r\n   * The field parameter specifies the names of the lat & lon coordinate fields \r\n   */\r\n  def segmentByLocation(docs:RDD[(String,Map[String,String])],fields:Array[String],clusters:Int,iterations:Int):RDD[(Int,String,Map[String,String])] = {\r\n    /**\r\n     * Train model\r\n     */\r\n    val vectors = docs.map(doc => toVector(doc._2,fields))   \r\n    val model = KMeans.train(vectors, clusters, iterations)\r\n    /**\r\n     * Apply model\r\n     */\r\n    docs.map(doc => {\r\n      \r\n      val vector = toVector(doc._2,fields)\r\n      (model.predict(vector),doc._1,doc._2)\r\n      \r\n    })\r\n    \r\n  }\r\n\r\n  private def toVector(data:Map[String,String], fields:Array[String]):Vector = {\r\n       \r\n    val lat = data(fields(0)).toDouble\r\n    val lon = data(fields(1)).toDouble\r\n      \r\n    Vectors.dense(Array(lat,lon))\r\n   \r\n  }\r\n  \r\n}\r\n```\r\n\r\nClustering Elasticsearch data with K-Means is a first and simple example of how to immediately benefit from the integration with Spark. Other business cases may cover recommendations:\r\n\r\nSuppose Elasticsearch is used to index e-commerce transactions on a per user basis, then it is also straightforward to build a recommendation system in just two steps:\r\n\r\n* **First**, implicit user-item ratings have to be derived from the e-commerce transactions, and  \r\n* **Second**, from this item similarities are calculated to provide a recommendation model.\r\n\r\nFor more information, please read [here](https://github.com/skrusche63/spark-elastic/wiki/Item-Similarity-with-Spark).\r\n\r\n\r\n#### <a name=\"1.1\"></a> Insights from Elasticsearch with SQL\r\n\r\n[Spark SQL](https://spark.apache.org/sql/) allows relational queries expressed in SQL to be executed using Spark. This enables to apply queries to Spark data structures and also to Spark data streams (see below).\r\n\r\nAs SQL queries generate Spark data structures, a mixture of SQL and native Spark operations is also possible, thus providing a sophisticated mechanism to compute valuable insight from data in real-time.\r\n\r\nThe code example below illustrates how to apply SQL queries on a Spark data structure (RDD) and provide further insight by mixing with native Spark operations.\r\n\r\n```\r\nimport org.apache.spark.SparkContext\r\nimport org.apache.spark.SparkContext._\r\n\r\nimport org.apache.spark.rdd.RDD\r\n\r\nimport org.apache.spark.sql.SQLContext\r\n\r\nimport org.json4s._\r\n\r\nimport org.json4s.native.Serialization\r\nimport org.json4s.native.Serialization.write\r\n\r\nobject EsInsight {\r\n\r\n  implicit val formats = Serialization.formats(NoTypeHints)\r\n\r\n  def insight(sc:SparkContext, docs:RDD[(String,Map[String,String])]) {\r\n    \r\n    val sqlc = new SQLContext(sc)\r\n\r\n    /**\r\n     * Convert docs into JSON\r\n     */\r\n    val jdocs = docs.map(valu => {\r\n      String.format(\"\"\"{\"id\":\"%s\",\"doc\":%s}\"\"\", valu._1, write(valu._2))\r\n    })\r\n\r\n    val table = sqlc.jsonRDD(jdocs)\r\n    table.registerAsTable(\"docs\")\r\n    /**\r\n     * Mixing SQL and other Spark operations\r\n     */\r\n    val subjects = sqlc.sql(\"SELECT doc.subject FROM docs\").filter(row => row.getString(0).contains(\"Re\"))    \r\n    subjects.foreach(subject => println(subject))\r\n    \r\n  }\r\n  \r\n}\r\n```\r\n\r\n\r\n***\r\n\r\n### <a name=\"2\"></a> Write to Elasticsearch using Kafka and Spark Streaming\r\n\r\nReal-time analytics is a very popular topic with a wide range of application areas:\r\n\r\n* High frequency trading (finance), \r\n* Real-time bidding (adtech), \r\n* Real-time social activity (social networks),\r\n* Real-time sensoring (Internet of things),\r\n* Real-time user behavior,\r\n\r\nand more, gain tremendous business value from real-time analytics. There exist a lot of popular frameworks to aggregate data in real-time, such as Apache Storm, \r\nApache S4, Apache Samza, Akka Streams, SQLStream to name just a few.\r\n\r\nSpark Streaming, which is capable to process about 400,000 records per node per second for simple aggregations on small records, significantly outperforms other popular \r\nstreaming systems. This is mainly because Spark Streaming groups messages in small batches which are then processed together. \r\n\r\nMoreover in case of failure, Spark Streaming batches are only processed once which greatly simplifies the logic (e.g. to make sure some values are not counted multiple times).\r\n\r\nSpark Streaming is a layer on top of Spark and transforms and batches data streams from various sources, such as Kafka, Twitter or ZeroMQ into a sequence of \r\nSpark RDDs (Resilient Distributed DataSets) using a sliding window. These RDDs can then be manipulated using normal Spark operations.\r\n\r\nThis project provides a real-time data integration pattern based on Apache Kafka, Spark Streaming and Elasticsearch: \r\n\r\n[Apache Kafka](http://kafka.apache.org/) is a distributed publish-subscribe messaging system, that may also be seen as a real-time integration system. For example, Web tracking events are easily sent to Kafka, \r\nand may then be consumed by a set of different consumers.\r\n\r\nIn this project, we use Spark Streaming as a consumer and aggregator of e.g. such tracking data streams, and perform a live indexing. As Spark Streaming is also able to directly \r\ncompute new insights from data streams, this data integration pattern may be used as a starting point for real-time data analytics and enrichment before search indexing.\r\n\r\nThe figure below illustrates the architecture of this pattern. For completeness reasons, [Spray](http://spray.io/) has been introduced. Spray is an open-source toolkit for \r\nbuilding REST/HTTP-based integration layers on top of Scala and Akka. As it is asynchronous, actor-based, fast, lightweight, and modular, it is an easy way to connect Scala \r\napplications to the Web.\r\n\r\n![Real-time Data Integration and Analytics](https://raw.github.com/skrusche63/spark-elastic/master/images/Real-time%20Data%20Integration%20and%20Analytics.png)\r\n\r\nThe code example below illustrates that such an integration pattern may be implemented with just a few lines of Scala code:\r\n\r\n```\r\n\r\nval stream = KafkaUtils.createStream[String,Message,StringDecoder,MessageDecoder](ssc, kafkaConfig, kafkaTopics, StorageLevel.MEMORY_AND_DISK).map(_._2)\r\nstream.foreachRDD(messageRDD => {\r\n  /**\r\n   * Live indexing of Kafka messages; note, that this is also\r\n   * an appropriate place to integrate further message analysis\r\n   */\r\n  val messages = messageRDD.map(prepare)\r\n  messages.saveAsNewAPIHadoopFile(\"-\",classOf[NullWritable],classOf[MapWritable],classOf[EsOutputFormat],esConfig)    \r\n      \r\n})\r\n\r\n```\r\n\r\n#### <a name=\"2.1\"></a> Count-Min Sketch and Streaming\r\n\r\nUsing the architecture as illustrated above not only enables to apply Spark to data streams. It also open real-time streams to other data processing libraries such as [Algebird](https://github.com/twitter/algebird) from \r\nTwitter.  \r\n\r\nAlgebird brings, as the name indicates, algebraic algorithms to streaming data. An important representative is [Count-Min Sketch](http://en.wikipedia.org/wiki/Count%E2%80%93min_sketch) which enables to compute the most \r\nfrequent items from streams in a certain time window. The code example below describes how to apply the CountMinSketchMonoid (Algebird) to compute the most frequent messages from a Kafka Stream with respect to the messages' classification: \r\n\r\n```\r\n\r\nobject EsCountMinSktech {\r\n    \r\n  def findTopK(stream:DStream[Message]):Seq[(Long,Long)] = {\r\n  \r\n    val DELTA = 1E-3\r\n    val EPS   = 0.01\r\n    \r\n    val SEED = 1\r\n    val PERC = 0.001\r\n \r\n    val k = 5\r\n    \r\n    var globalCMS = new CountMinSketchMonoid(DELTA, EPS, SEED, PERC).zero\r\n \r\n    val clases = stream.map(message => message.clas)\r\n    val approxTopClases = clases.mapPartitions(clases => {\r\n      \r\n      val localCMS = new CountMinSketchMonoid(DELTA, EPS, SEED, PERC)\r\n      clases.map(clas => localCMS.create(clas))\r\n    \r\n    }).reduce(_ ++ _)\r\n\r\n    approxTopClases.foreach(rdd => {\r\n      if (rdd.count() != 0) globalCMS ++= rdd.first()\r\n    })\r\n        \r\n    /**\r\n     * Retrieve approximate TopK classifiers from the provided messages\r\n     */\r\n    val globalTopK = globalCMS.heavyHitters.map(clas => (clas, globalCMS.frequency(clas).estimate))\r\n      /*\r\n       * Retrieve the top k message classifiers: it may also be interesting to \r\n       * return the classifier frequency from this method, ignoring the line below\r\n       */\r\n      .toSeq.sortBy(_._2).reverse.slice(0, k)\r\n  \r\n    globalTopK\r\n    \r\n  }\r\n}\r\n\r\n```\r\n\r\n***\r\n\r\n### <a name=\"3\"></a> Technology Stack\r\n\r\n* [Scala](http://scala-lang.org)\r\n* [Apache Kafka](http://kafka.apache.org/)\r\n* [Apache Spark](http://spark.apache.org)\r\n* [Spark SQL](https://spark.apache.org/sql/)\r\n* [Spark Streaming](https://spark.apache.org/streaming/)\r\n* [Twitter Algebird](https://github.com/twitter/algebird)\r\n* [Elasticsearch](http://elasticsearch.org)\r\n* [Elasticsearch Hadoop](http://elasticsearch.org/overview/hadoop/)\r\n* [Spray](http://spray.io/)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}